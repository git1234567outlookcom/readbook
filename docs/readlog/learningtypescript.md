# Learning TypeScript

# TypeScript 简介

- 设计目标
  - 编译器进行静态类型分析的强类型语言
  - js 的超集
  - 加入了基于类的对象、接口和模块，提供一个构建机制
  - 术语
    - design time code 设计时代码
    - execution time code 执行时代码
    - runtime code 运行时代码
- ts 组件

  - 语言层：实现所有 ts 的语言特性
  - 编译层：进行代码转换
  - 语言服务层：生成信息
  - IDE 整合

---

- 类型
  - boolean
  - number
  - string
  - array
  - enum
  - any 任意类型 js 值
  - void any 的对立面，所有的类型都不存在的时候

---

变量声明：var、let、const

- var ：作用域 函数
- let 保存在最近的 比函数作用域小的块作用域中
- const：创建一个保存在创建位置作用域中的常量

---

联合类型

`TypeScript var path : string[]| string;`

用来生命那些可以存储多种类型值的变量

---

运算符

默认包含一个名为 lib.d.ts 的文件

提供了像 dom 这中 js 内置库的接口

- == 比较两个元素的值
- === 比较值和类型

---

> 代码 test1.ts

---

# 自动化工作流程

- 版本控制
- 包管理
- 自动化任务 grunt gulp
- 自动化测试 karma
- 持续集成 CI Travis CI
- 脚手架 Yeoman

自动化测试工具 Karma

测试框架 Mocha

chai（断言库）

sinon（数据模拟框架）

---

# 使用函数

> test3.ts

- 四种异步流程控制
  - 并行：异步任务将会并行执行
  - 串行：一组任务串行，
  - 瀑布流：一组任务串行，每个任务的结果传到下一个任务中
  - 混合：并行、串行和瀑布流的任意组合

# ts 中的面向对象编程

## SOLID 原则

- 单一职责原则 SRP
- 开/闭原则ocp
- 里氏替换原则lsp：派生类对象能够替换其基类对象被使用
- 接口隔离原则isp：接口被用来声明两个或更多的应用组件是如何互相操作和交换信息的
- 依赖反转原则 dip：表示一个方法应该遵从依赖于抽象而不是一个实例



## 接口

- 接口可以扩展其他接口或者类
- 接口可以定义数据和行为



---


### 关联 Association

有联系但是他们的对象有独立的生命周期，并且没有从属关系的类之间的关系

例：老师和学生

### 聚合 Aggreation

拥有独立的生命周期，但是有从属关系，子对象不能从属于其他对象的关系

### 组合 Composition

没有独立生命周期，父对象被删除后子对象也被删除的对象间的关系


### 继承 Inheritance
   
可以扩展已有的类

可以使用关键字 extends  

super：子类中能提供父类中同名方法的特殊实现

这种子类提供父类已有方法的特殊实现的功能被称作 **方法重写**



### 混合

一个同时继承两个或多个类的类，也叫多重继承  

子类只能extends 一个父类

implements 可以继承多个类

方法重名后，只会传入最后继承类中的方法


### 范型类

类名后面加<T>



### 模块

模块声明之后，通过模块加载器来加载，不会使用script标签引入他们

模块加载器是在模块加载过程中为我们提供了更好控制能力的工具

优化加载任务


- RequireJS   使用一个被称作异步模块定义的语法AMD 
- Browserify   CommonJs
- SystemJs   通用模块加载器，支持所有的模块定义语法


可以在运行环境中选择使用哪一种模块语法    

- tsc -- module  system main.ts







# 运行时


- 运行时环境
- 事件循环
- this操作符
- 原型
- 闭包



> 文档对象模型  DOM

用于动态访问和更新页面中视图结构的接口

独立于平台和语言

模型的数据可以被进一步处理和修改

并且修改会反映在当前视图中

DOM 只存于浏览器中


> 浏览器对象模型  BOM

仅在浏览器运行环境下特有的对象集合

包含了导航栏、历史记录、屏幕、地址栏和文档等窗口对象





> 运行时环境

是一个基于事件循环的并发模型

堆 heap、栈stack、队列queue、桢frame



## 桢

一个桢是一个连续的工作单元

js函数被调用时 

运行时环境就会在栈中创建一个桢

桢里保存了特殊函数的参数和局部变量

函数返回时

桢就被从栈中推出


## 栈

包含了一个信息在执行时的所有步骤（桢）

栈的数据结构为一个后进先出的对象集合

## 队列

包含一个待执行信息的队列

每一个信息都与一个函数相互联系

## 堆 

是一个内存存储空间

保存了所有正在被使用的变量和对象

同时也保存了一些没用到也没被垃圾回收的桢


## 事件循环


并发是指同一事件有两个或更多的操作一起执行

事件虚幻内的信息是线性执行的

可以用yield和生成器函数来暂停一个函数的执行


## this操作符

通常由它所属的函数被调用的方式来决定

它的值不能在执行时通过赋值操作来设置

- 全局上下文中的this   window对象是全局对象

- 函数上下文中的this操作符


> 所有的函数都从Function.prototype中继承了 call、 apply、 bind 方法
> 可以使用这写方法来设置函数内部this操作符的值

apply =》  array

c =》 call

， =》 comma






## 原型

运行时的继承系统使用的是原型继承模型

在一个原型继承模型中，并没有类，对象直接继承自对象

几乎所有的js对象都有一个内部的名为prototype 的属性

这个属性的值 使一个对象

ts编译器使用一个 **立即调用函数表达式** 包装了一个对象声明


实例属性与类属性对比

实例属性都保存着每个实例各自的值

类属性经常用来保存一些静态值


## 基于原型的继承

