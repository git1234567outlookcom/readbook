# Learning TypeScript

# TypeScript 简介

- 设计目标
  - 编译器进行静态类型分析的强类型语言
  - js 的超集
  - 加入了基于类的对象、接口和模块，提供一个构建机制
  - 术语
    - design time code 设计时代码
    - execution time code 执行时代码
    - runtime code 运行时代码
- ts 组件

  - 语言层：实现所有 ts 的语言特性
  - 编译层：进行代码转换
  - 语言服务层：生成信息
  - IDE 整合

---

- 类型
  - boolean
  - number
  - string
  - array
  - enum
  - any 任意类型 js 值
  - void any 的对立面，所有的类型都不存在的时候

---

变量声明：var、let、const

- var ：作用域 函数
- let 保存在最近的 比函数作用域小的块作用域中
- const：创建一个保存在创建位置作用域中的常量

---

联合类型

`TypeScript var path : string[]| string;`

用来生命那些可以存储多种类型值的变量

---

运算符

默认包含一个名为 lib.d.ts 的文件

提供了像 dom 这中 js 内置库的接口

- == 比较两个元素的值
- === 比较值和类型

---

> 代码 test1.ts

---

# 自动化工作流程

- 版本控制
- 包管理
- 自动化任务 grunt gulp
- 自动化测试 karma
- 持续集成 CI Travis CI
- 脚手架 Yeoman

自动化测试工具 Karma

测试框架 Mocha

chai（断言库）

sinon（数据模拟框架）

---

# 使用函数

> test3.ts

- 四种异步流程控制
  - 并行：异步任务将会并行执行
  - 串行：一组任务串行，
  - 瀑布流：一组任务串行，每个任务的结果传到下一个任务中
  - 混合：并行、串行和瀑布流的任意组合

# ts 中的面向对象编程

## SOLID 原则

- 单一职责原则 SRP
- 开/闭原则ocp
- 里氏替换原则lsp：派生类对象能够替换其基类对象被使用
- 接口隔离原则isp：接口被用来声明两个或更多的应用组件是如何互相操作和交换信息的
- 依赖反转原则 dip：表示一个方法应该遵从依赖于抽象而不是一个实例



## 接口

- 接口可以扩展其他接口或者类
- 接口可以定义数据和行为



---


### 关联 Association

有联系但是他们的对象有独立的生命周期，并且没有从属关系的类之间的关系

例：老师和学生

### 聚合 Aggreation

拥有独立的生命周期，但是有从属关系，子对象不能从属于其他对象的关系

### 组合 Composition

没有独立生命周期，父对象被删除后子对象也被删除的对象间的关系


### 继承 Inheritance
   
可以扩展已有的类

可以使用关键字 extends  

super：子类中能提供父类中同名方法的特殊实现

这种子类提供父类已有方法的特殊实现的功能被称作 **方法重写**



### 混合

一个同时继承两个或多个类的类，也叫多重继承  

子类只能extends 一个父类

implements 可以继承多个类

方法重名后，只会传入最后继承类中的方法


### 范型类

类名后面加<T>



### 模块

模块声明之后，通过模块加载器来加载，不会使用script标签引入他们

模块加载器是在模块加载过程中为我们提供了更好控制能力的工具

优化加载任务


- RequireJS   使用一个被称作异步模块定义的语法AMD 
- Browserify   CommonJs
- SystemJs   通用模块加载器，支持所有的模块定义语法


可以在运行环境中选择使用哪一种模块语法    

- tsc -- module  system main.ts







# 运行时


- 运行时环境
- 事件循环
- this操作符
- 原型
- 闭包



> 文档对象模型  DOM

用于动态访问和更新页面中视图结构的接口

独立于平台和语言

模型的数据可以被进一步处理和修改

并且修改会反映在当前视图中

DOM 只存于浏览器中


> 浏览器对象模型  BOM

仅在浏览器运行环境下特有的对象集合

包含了导航栏、历史记录、屏幕、地址栏和文档等窗口对象





> 运行时环境

是一个基于事件循环的并发模型

堆 heap、栈stack、队列queue、桢frame



## 桢

一个桢是一个连续的工作单元

js函数被调用时 

运行时环境就会在栈中创建一个桢

桢里保存了特殊函数的参数和局部变量

函数返回时

桢就被从栈中推出


## 栈

包含了一个信息在执行时的所有步骤（桢）

栈的数据结构为一个后进先出的对象集合

## 队列

包含一个待执行信息的队列

每一个信息都与一个函数相互联系

## 堆 

是一个内存存储空间

保存了所有正在被使用的变量和对象

同时也保存了一些没用到也没被垃圾回收的桢


## 事件循环


并发是指同一事件有两个或更多的操作一起执行

事件虚幻内的信息是线性执行的

可以用yield和生成器函数来暂停一个函数的执行


## this操作符

通常由它所属的函数被调用的方式来决定

它的值不能在执行时通过赋值操作来设置

- 全局上下文中的this   window对象是全局对象

- 函数上下文中的this操作符


> 所有的函数都从Function.prototype中继承了 call、 apply、 bind 方法
> 可以使用这写方法来设置函数内部this操作符的值

apply =》  array

c =》 call

， =》 comma






## 原型

运行时的继承系统使用的是原型继承模型

在一个原型继承模型中，并没有类，对象直接继承自对象

几乎所有的js对象都有一个内部的名为prototype 的属性

这个属性的值 使一个对象

ts编译器使用一个 **立即调用函数表达式** 包装了一个对象声明


实例属性与类属性对比

实例属性都保存着每个实例各自的值

类属性经常用来保存一些静态值


## 基于原型的继承

遍历父类的所有属性赋给子类


## 原型链

访问一个对象的属性或方法时，运行时将会搜索对象自身原型上的属性和方法

没有找到就会沿着对象的继承树继续照

由于父类对象通过原型链接了子类

这种继承树为原型链


继承了一个同名的方法

当访问这个方法时

访问到的将是对象自己原型上的那个方法

成为原型遮蔽  property shadowing 


## 访问对象的原型


- Person.prototype  
- Person.getPrototypeOf(person)
- person._proto_


## new 操作符

运行时js的new和程序设计阶段ts的extends关键字的行为没有区别

## 闭包

闭包是指向独立变量的函数

在闭包中定义的函数会‘记住’它创建时的环境

可以将独立变量理解为在我们创建的字面作用域上持续存在的变量

## 闭包和静态变量

静态变量被ts编译器声明为了类属性

之所以使用类属性是因为它被所有实例共享

单例模式使一个对象可以像静态变量一样被声明


## 闭包和私有成员

闭包函数可以访问到在创建字面作用域上持续存在的变量

这些变量不是函数原型或函数体中的一部分

是闭包上下文中的一部分

# 应用性能

- 性能与资源
- 性能的各个方面
- 内存性能分析
- 网络心鞥分析
- CPU与GPU的性能分析
- 性能测试
- 性能优化建议
- 性能自动化测试



## 性能指标

- 可用性
- 响应事件
    - 等待时间
    - 服务时间
    - 传输时间
- 处理速度
- 延迟
- 带宽
- 可伸缩性
- 性能分析
- 网络性能分析

    

- 提高web应用的速度
    - 压缩http请求
    - 使用cdn
    - 避免空的src和href属性
    - 增加expires或缓存头
    - 使用Gzip压缩软件
    - 把样式表放在顶部
    - 把脚本放在底部
    - 避免css表达式（动态属性）
    - js和css放到外部链接
    - 减少dns查询
    - 压缩js 和css
    - 避免重定向
    - 移除重复的脚本
    - 配置Etags
    - 缓存Ajax请求
    - 多用get请求
    - 避免404
    - 不在html中扩展图片
    - 将favicon.ico压缩并缓存
    
    


stats.js 帧率监控


# 应用测试



> 断言

是一个条件，必须是被测试确认的一段代码的行为是否与期望相符



- 测试规范
    - 是一个详细的测试清单，包含测试场景
- 测试用例
    - 决定一个程序中的功能是否按照原始期望工作的一些条件
- 测试套件
    - 是许多测试用例的集合
- 测试桩
    - 允许包裹一个方法然后观察它的使用情况
- 模拟
    - mock



Glup 

任务运行器运行一些必要的任务来执行测试

Karma

测试运行器

lstanbul

指出哪一行代码在自动化测试中被测试到的工具


Mocha

一个流行的js测试框架库

Chai

支持测试驱动开发TDD和行为驱动开发BDD测试风格的断言库


Sinon.JS

独立的框架，提供一组API可以帮助独立的测试一个组件


PhantomJS

无显示界面的浏览器




> 测是驱动开发

1. 编写一个不通过的测试
2. 运行这个测试，保证它不通过
3. 编写应用代码，让测试通过
4. 运行这个测试，保证它能通过
5. 运行所有其他测试，保证程序的其他部分没有被破坏
6. 重复以上步骤


- 测试类型
    - 单元测试
    - 部分集成测试和整体集成测试
    - 回归测试
    - 性能/加载测试
    - 端对端测试
    - 验收测试UAT
    


# 装饰器

- 注解和装饰器
    - 类装饰器
    - 方法装饰器
    - 属性装饰器
    - 参数装饰器
    - 装饰器工厂
    - 带有参数的装饰器
- 元数据反射api





##  注解和装饰器

> 注解是一种为类声明添加元数据的方法
> 元数据就可以被诸如依赖注入容器这样的工具所使用


使用注解不用关心它书如何让将元数据加入到代码里的

装饰器则更像是一个接口，用来构建一个以注解功能结尾的东西


装饰器可以装饰： 类、属性、方法、和参数




### 类装饰器

类装饰器是指接受一个类构造函数作为参数的函数

并且返回undefined、
参数中提供的构造函数或一个新的构造函数

返回undefined 等同于返回参数中提供的构造函数



> 类装饰器就用来修改类的构造函数。
> 返回dundefined，表示使用原来的构造函数
> 有返回值，会被用来覆盖原来的构造函数




### 方法装饰器

是一个接受三个参数的函数

包括这个属性的对象、属性名、可选参数

返回undefined 等于返回参数里提供的属性描述对象


### 装饰器工厂

**这有个警告**
需要修改tsconfig.json


```json
{
    "compilerOptions": {
        "experimentalDecorators": true,
        "allowJs": true
    }
}
```  



装饰器工厂是一个接受任意数量参数的函数：并且返回上述的任意一种装饰器


带有参数的装饰器


可以访问到装饰器的参数


### 反射元数据API




# 应用架构

## 单页面应用架构

SPA就是一个web应用，所需的html、css、js在一次请求中就加载完成，不需要刷新动态加载


## MV* 架构


Model - View - Controller 

Model-View-ViewModel

Model-View-Presenter



## MV* 框架中的组件和功能

- model

用来存储数据的组件

- collection

用来表示一组model

- item view 

view 负责将存储在model中的数据渲染成html

view 通常依赖在构造函数、属性或设置中传入一个model、一个模版、和一个容器

容器通常是一个dom元素选择器

- collection view

conllection view 通常依赖在构造函数、属性或者设置中传入一个collection、一个item view、和一个容器

- controller

通常负责管理特定的model和相关view的声明周期


## 事件 

事件是被程序发现的行为或发生的事情

- 用户事件
- 程序事件


## 路由和hash（#）导航

路由负责观察URL的变更，并将程序的执行流切换到controller的相应方法上

spa中，链接通常包含一个hash# 自负，用来做无须刷新的导航




## 中介器

所有其他的模块都通过它与其他部分进行通信

实现与发布/订阅设计模式，让模块之间不用相互依赖

模块可以监听一个事件并处理它，也可以发布一个事件让其他模块响应这个事件，保证程序模块间的低耦合


## 调度器

dispatch 指向一个叫做调度器的东西，路由在向调度器发送事件而不是controller


## 客户端渲染和 Virtual DOM



model渲染检测

- 定时器检测变更
- observable model


observable 的实现比使用定时器更高效，仅在变更发生的时候触发

## 用户界面数据绑定

- 单项数据绑定
- 双向数据绑定

## 数据流 


数据流架构试图通过把数据的流动限制为唯一的渠道和方向

Flux的单项数据流架构中，所有的action都直接发送到dispatcher中

sotre用来存储和操作数据



## Web component 和shadow DOM


web component 指代那些可以重用的UI组件



## 从零开始实现一个MVC框架

- 程序组件

程序的根组件，程序组件负责初始化框架内所有的内部组件

- 中介器

负责程序中所有其他模块间的通信

- 程序事件

程序事件被用来将信息从一个组件发送到另一个，组件可以发布程序事件也可以订阅或取消订阅一个程序事件

- 路由 

观察浏览器url的变更，并在变更时创建一个Route类的实例，通过程序事件传递给调度器

- 路由表

用来表示一个URL，命名规则可以指明哪一个controller的方法在特定路由下被调用

- 调度器

调度器接收一个Route类的实例，这个实例被用来指定依赖的controller

- controller

被用来初始化view和model，一旦初始化完成，controller就将执行流交给一个或多个model

- model 

负责与http api 通信，并在内存中维护这些数据，一旦model完成了对数据的操作，就被传递到一个或多个view中

- view 

负责加载并编译模板，一旦模板编译完成，就会等待model传入数据，会和模版一起被编译成html代码插入dom



![关系图](/docs/readlogimg/js架构.png)


