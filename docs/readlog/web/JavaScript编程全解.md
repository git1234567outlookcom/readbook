# JavaScript编程全解

dom编程就是浏览器和用户之间的接口

dom对客户端js来说，仅仅是一个宿主对象


- 客户端
    - dom + 内置宿主对象
- 服务器端
    - 内置宿主对象
- 浏览器扩展
    - 宿主对象
    
- js核心语言内置对象


不同的运行环境，有这不同的内置宿主对象

扩展语言是在内建对象的应用程序（就是宿主环境）中运行的程序

宿主应用程序会在这时收到一些运行时的上下文信息


js会以全局对象作为根节点的对象树的形式

启动时，js从宿主环境获取的对象树就被成为宿主对象

全局对象在程序启动前就已经存在了

客户端js的全局对象被称作windoss对象
 

## js特点

- 解释型语言
- 基于原型的面向对象
- 动态语言



js对象的属性值可以由函数指定

js具备成为原型链的构造，类似于继承

prototype 对象的属性和实例属性，都是以对象实例的形式来进行访问的

例： str.length   str.trim()

prototype 对象的属性和实例属性之间的不同点在于不是否进行了继承



- 数据类型
    - 字符串
    - 数值
    - 布尔
    - null
    - undefinded
    - object 

类型就是行为方式上的共性，每个对象都具有共同的行为方式，所以可以使用原型对象

这样的编程风格称为基于原型的风格



基本数据类型变量：直接保存有数值等类型的数据的值

引用类型变量：则保存有对象的引用


内建数据类型 build in type分为五种基本数据类型和object


--- 


new String 实际上用的是构造函数 

字符串的内容是不可变的

数字在53位以内


--- 


new Number

参数无法转换为数值类型，就会返回的NaN


NaN 进行任何运算结果都是NaN


--- 

布尔型，只能够取真true和false


---

null型 只能够取null这一个值


undefined 型 只能够取undefined 这一个值  


是一个预定义的全局变量

null 是一种字面量而undefined是一个变量名

要使一个变量的值为null，必须将null以字面量的形式赋值给该变量

undefined值最多只能算是某个没有经过显示赋值的变量的初始值，没有定义或没有初始化

```js
var x  ;
console.log(typeof x);
console.log(typeof xx);
```

- 未初始化的变量的值
- 不存在的属性的值
- 在没有传入实参而调用函数时，该函数内相应参数的值
- 没有return 语句或是return 语句中不含表达式的函数的返回值
- 对void运算符求值的结果（通常使用 void 0 来获取一个undefined值）


--- 



object 类型

除了五种基本类型，其他说有类型都是object类型


---

## 数据类型转换


- 字符串转换为数值

Number ：如果有非数值则返回NaN
parseInt  parseFloat ： 将会忽略数字以外的其他字符

- 数值转字符串

- 转换为布尔

0 、 NaN 、 null 、 undefined 、 空字符串值




# 语句、表达式和运算符


- 标识符

必须是除保留字以外

除true 、 false 、 null 以外

以Unicode 非空字符开始

单词长度没有限制

区分大小写

下划线开始的会被作为内部标示符



- for in 

枚举的顺序：是以字面量书写的顺序来进行枚举的

无法被枚举的属性：一些属性树不能够被枚举的

由原型继承而来的属性：可以枚举由原型继承而来的属性

```js
 var obj = {x:1,y:2,z:3};
 
 for (var i in obj){
     console.log(i)
 } 
```

- for each in 

- break 

- continue

- return 


```js
try {
  console.log('this is try ')
} catch (e) {
  console.log('打印错误')
} finally {
  console.log('始终都会执行')
}
```

---


- 全等运算符
    - x与y数据类型不相符，则结果为flase
    - 都会undefined值或者两者都是null值情况，结果为真
    - 两者都是数值，数值相等为true
    - 都为字符串，内容一致为真
    - 布尔值，一致为true
    - 对象引用，引用的是同一个对象则结果为true，否则结果为flase
    
- == 会进行隐式数据转换
    - 数据类型相同，与全等运算结果想过相同
    - 数据类型不相同时：
        - null == undefined    true
        - 当类型不一致时会先进行隐式转换，在进行比较
        
        
---        
        

in 检验属性是否存在的运算符

instanceof  用于类型判断的运算符

typeof 用于数据类型判定的单目运算符

new 用于生成对象

delete 用于删除属性的单目运算符

void 是undefined类型的单目运算符


.  [] 访问属性的运算符

() 来实现函数额调用




# 第五章 变量与对象

变量又分为基本类型变量和引用类型的变量

引用类型：用于指出对象的位置的标记

局部变量是在调用函数时被隐式生成的对象的属性

被隐式生成的对象称为call对象




## 构造函数与 new 表达式

- 构造函数本身和普通的函数声明形式相同
- 构造函数通过new表达式来调用
- 调用构造函数的 new 表达式的值是被新生成的对象的引用
- 通过new表达式调用的构造函数内的this引用  引用的被新生成的对象、


---

new 表达式在求值时的操作

首先生成一个不具有特别的操作对象

之后通过new表达式调用指定的函数

构造函数内的this引用  引用了新生成的对象

构造函数会在最后隐式的执行 return this操作



--- 


## 属性的访问

.  或者  [] 

当指定的是不存在的属性名，则会新增该属性


--- 

实现不可变对象的方式

- 将属性隐藏，不提供变更擦欧总
- 灵活使用 writable、configurable、setter、getter


seal 的作用是将属性的configurable属性置为false

freeze是将writable属性置为false



## 方法


this  引用可以在最外层代码使用，

this引用  引用的是一个对象

在最外层的代码用，this引用的是全局对象

在函数内
- 构造函数调用，this  所生成的对象
- 方法调用， this  接受方对象
- apply或者是call调用，this  apply或者call的参数指定的对象
- 其他方式的调用， this  全局对象



